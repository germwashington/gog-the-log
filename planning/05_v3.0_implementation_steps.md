# v3.0 Implementation Steps - Piece by Piece Guide

## Overview
This document breaks down the v3.0 modular architecture implementation into small, discrete, testable steps. Each step must be completed and verified before moving to the next. This ensures we build on a solid foundation rather than trying to fix everything at once.

---

## Implementation Philosophy

### Core Principles
1. **One piece at a time** - Complete and verify each step before starting the next
2. **Test immediately** - After each step, verify it works in isolation
3. **Build incrementally** - Each step builds on the previous working foundation
4. **No assumptions** - Verify everything works, don't assume it will
5. **Clear success criteria** - Know exactly what "working" means for each step

### Verification Checklist (for each step)
- [ ] Code compiles/runs without errors
- [ ] Step-specific test passes
- [ ] Can see expected output/behavior
- [ ] No regressions in previous steps
- [ ] **Game remains playable** (if applicable to step)
- [ ] Ready to move to next step

### Phase Completion Checklist (for each phase)
- [ ] All steps in phase completed
- [ ] Phase-specific functionality works
- [ ] **Game remains playable using new modular code** (critical requirement)
- [ ] All modules integrate correctly
- [ ] Telemetry logs phase activities (if telemetry is available)
- [ ] Ready to move to next phase

---

## Phase 0: Preparation & Setup

### Step 0.1: Create Directory Structure
**Goal**: Set up the file structure for all modules

**Actions**:
1. Create `docs/modules/` directory
2. Create subdirectories:
   - `docs/modules/yawgmoth/`
   - `docs/modules/telemetry-system/`
   - `docs/modules/character-trafficker/`
   - `docs/modules/enemy-controller/`
   - `docs/modules/readme-guy/`
   - `docs/modules/leonardo-da-vinci/`
   - `docs/modules/bookwormy-guy/data/`

**Success Criteria**:
- All directories exist
- Directory structure matches plan

**Test**: Run `ls -R docs/modules/` and verify structure

---

### Step 0.2: Backup Current game.js
**Goal**: Preserve working v2.0 code as reference

**Actions**:
1. Copy `docs/game.js` to `docs/game-v2.0-backup.js`
2. Create `docs/reference/` directory
3. Copy all v2.0 files to reference directory

**Success Criteria**:
- Backup files exist
- Can reference original code

**Test**: Verify backup file exists and is readable

---

### Step 0.3: Create Empty Module Files
**Goal**: Create placeholder files for all modules

**Actions**:
1. Create all main module files with empty class stubs:
   - `docs/modules/bookwormy-guy.js`
   - `docs/modules/telemetry-system.js`
   - `docs/modules/yawgmoth.js`
   - `docs/modules/leonardo-da-vinci.js`
   - `docs/modules/character-trafficker.js`
   - `docs/modules/enemy-controller.js`
   - `docs/modules/readme-guy.js`
2. Each file should export a class with constructor only
3. Create `docs/main.js` as entry point (empty for now)

**Success Criteria**:
- All files exist
- Files can be imported without errors
- No syntax errors

**Test**: Create test HTML that imports all files, verify no console errors

### Phase 0 Completion Criteria
**Critical**: Before moving to Phase 1, verify:
- [ ] All module directories created
- [ ] All module files created (empty stubs)
- [ ] Original game.js backed up to game-v2.0-backup.js
- [ ] All files can be imported without errors
- [ ] **Game remains playable** - Original game.js still works (we haven't modified it yet)
- [ ] Ready to start extracting data to modules

**Note**: At this point, the game still uses the original game.js. We're just setting up the structure for modular code.

---

## Phase 1: Bookwormy Guy (Data Store) - Foundation

### Step 1.1: Extract Enemy Definitions
**Goal**: Move enemy type definitions to Bookwormy Guy

**Actions**:
1. Open `docs/game-v2.0-backup.js`
2. Find all enemy type definitions (in `setupEnemyType` method)
3. Create `docs/modules/bookwormy-guy/data/enemies.js`
4. Extract enemy definitions into structured data:
   ```javascript
   export const ENEMY_TYPES = {
       'basic': { health: 30, baseSpeed: 100, width: 30, height: 30, ... },
       'scout': { health: 10, baseSpeed: 120, ... },
       // ... etc
   };
   ```
5. Update `docs/modules/bookwormy-guy.js` to import and provide `getEnemyType(type)` method

**Success Criteria**:
- All enemy types extracted
- `getEnemyType('basic')` returns correct data
- No data lost in extraction

**Test**: 
```javascript
import { BookwormyGuy } from './modules/bookwormy-guy.js';
const bg = new BookwormyGuy();
const basic = bg.getEnemyType('basic');
console.assert(basic.health === 30, 'Basic enemy health should be 30');
```

---

### Step 1.2: Extract Weapon Definitions
**Goal**: Move weapon system data to Bookwormy Guy

**Actions**:
1. Find `WeaponSystem.weapons` object in backup
2. Create `docs/modules/bookwormy-guy/data/weapons.js`
3. Extract all 8 weapon definitions
4. Add `getWeapon(weaponType, level)` method to BookwormyGuy

**Success Criteria**:
- All 8 weapons extracted
- `getWeapon('pistol', 1)` returns correct stats
- Upgrade levels preserved

**Test**:
```javascript
const pistol = bg.getWeapon('pistol', 1);
console.assert(pistol.baseFireRate === 300, 'Pistol fire rate correct');
```

---

### Step 1.3: Extract Level Configurations
**Goal**: Move all level configs to Bookwormy Guy

**Actions**:
1. Find `getLevelConfig()` method in backup
2. Create `docs/modules/bookwormy-guy/data/levels.js`
3. Extract all 25 level configurations (5 stages × 5 levels)
4. Add `getLevelConfig(stage, level)` method

**Success Criteria**:
- All 25 levels extracted
- `getLevelConfig(1, 1)` returns correct config
- Enemy types, spawn rates, speeds all preserved

**Test**:
```javascript
const level1_1 = bg.getLevelConfig(1, 1);
console.assert(level1_1.spawnRate === 3000, 'Level 1-1 spawn rate correct');
```

---

### Step 1.4: Extract Stage Configurations
**Goal**: Move stage data to Bookwormy Guy

**Actions**:
1. Find `getStageConfig()` method in backup
2. Create `docs/modules/bookwormy-guy/data/stages.js`
3. Extract all 5 stage configurations
4. Add `getStageConfig(stageNumber)` method

**Success Criteria**:
- All 5 stages extracted
- `getStageConfig(1)` returns correct colors, names, etc.

**Test**: Verify stage 1 returns Deep Space config with correct colors

---

### Step 1.5: Extract Visual Data
**Goal**: Move visual/rendering data to Bookwormy Guy

**Actions**:
1. Extract color palettes, sizes, visual constants
2. Create `docs/modules/bookwormy-guy/data/visuals.js`
3. Add methods: `getColorPalette(stage)`, `getParticleEffect(name)`, etc.

**Success Criteria**:
- Visual data accessible via Bookwormy Guy
- Colors match v2.0

**Test**: Verify color palettes match original

---

### Step 1.6: Extract Game Configuration
**Goal**: Move game constants to Bookwormy Guy

**Actions**:
1. Extract all game constants (screen size, collection ranges, etc.)
2. Create `docs/modules/bookwormy-guy/data/config.js`
3. Add `getGameConfig()` and `getConstant(name)` methods

**Success Criteria**:
- All constants accessible
- `getConstant('COLLECTION_RANGE')` returns correct value

**Test**: Verify key constants match v2.0

---

### Step 1.7: Complete Bookwormy Guy API
**Goal**: Implement all public API methods

**Actions**:
1. Review Bookwormy Guy API from architecture doc
2. Implement all missing methods
3. Add error handling (return null/undefined for invalid queries)
4. Add JSDoc comments to all methods

**Success Criteria**:
- All API methods implemented
- Methods handle invalid inputs gracefully
- Can query all data types

**Test**: Create comprehensive test that calls every API method and verifies results

### Phase 1 Completion Criteria
**Critical**: Before moving to Phase 2, verify:
- [ ] Bookwormy Guy module is complete and all data accessible
- [ ] **Game remains playable** - If game.js still exists, it should still work (we haven't replaced it yet)
- [ ] All data from v2.0 is preserved in Bookwormy Guy
- [ ] Can query all enemy types, weapons, levels, stages, visuals, and configs
- [ ] No data was lost in extraction

**Note**: At this point, the game still uses the original game.js. Bookwormy Guy is ready to be used by other modules.

---

## Phase 2: Telemetry System - Observability Foundation

### Step 2.1: Create IndexedDB Storage
**Goal**: Set up persistent log storage

**Actions**:
1. Create `docs/modules/telemetry-system/storage.js`
2. Implement IndexedDB database creation
3. Implement `saveLog(logEntry)` method
4. Implement `loadLogs(sessionId)` method
5. Test IndexedDB operations

**Success Criteria**:
- Can create/open IndexedDB database
- Can save log entries
- Can retrieve saved logs
- No IndexedDB errors

**Test**:
```javascript
const storage = new TelemetryStorage();
await storage.saveLog({ id: 'test1', timestamp: Date.now(), type: 'test' });
const logs = await storage.loadLogs('test-session');
console.assert(logs.length > 0, 'Logs saved and retrieved');
```

---

### Step 2.2: Create Core Logger
**Goal**: Basic logging functionality

**Actions**:
1. Create `docs/modules/telemetry-system/logger.js`
2. Implement `logEvent()`, `logMethodCall()`, `logQuery()`, `logStateChange()` methods
3. Store logs in memory array
4. Generate unique log IDs and timestamps

**Success Criteria**:
- Can log events, method calls, queries, state changes
- Logs have correct format (id, timestamp, type, source, target, data)
- Logs stored in memory

**Test**: Log various types of entries, verify format and content

---

### Step 2.3: Connect Logger to Storage
**Goal**: Persist logs to IndexedDB

**Actions**:
1. Integrate logger with storage
2. Auto-save logs to IndexedDB periodically (every N entries or every N seconds)
3. Implement log rotation (keep last 10 sessions)

**Success Criteria**:
- Logs automatically saved to IndexedDB
- Can retrieve logs after page reload
- Old logs rotated/deleted

**Test**: Log entries, reload page, verify logs still exist

---

### Step 2.4: Create Log Viewer UI
**Goal**: Visual interface to view logs

**Actions**:
1. Create `docs/modules/telemetry-system/viewer.js`
2. Create HTML overlay (hidden by default)
3. Display log entries in scrollable list
4. Show: timestamp, type, source → target, action, data preview
5. Add toggle hotkey (F12)

**Success Criteria**:
- Can toggle viewer with hotkey
- Logs display in real-time
- Viewer doesn't interfere with game

**Test**: Open viewer, verify logs appear, toggle on/off

---

### Step 2.5: Add Log Filtering
**Goal**: Filter logs by module, type, time

**Actions**:
1. Add filter controls to viewer UI
2. Implement filtering by:
   - Module name (source or target)
   - Log type (event, method, query, state, error)
   - Time range
3. Add search box for log content

**Success Criteria**:
- Can filter logs by module
- Can filter by type
- Can search log content
- Filters work in real-time

**Test**: Generate logs from multiple modules, verify filters work

---

### Step 2.6: Complete Telemetry System
**Goal**: Full telemetry API

**Actions**:
1. Implement all TelemetrySystem API methods from architecture doc
2. Add performance metrics tracking
3. Add export functionality (JSON download)
4. Add interaction graph data generation

**Success Criteria**:
- All API methods work
- Performance metrics tracked
- Can export logs
- System ready to integrate with other modules

**Test**: Comprehensive test of all telemetry features

### Phase 2 Completion Criteria
**Critical**: Before moving to Phase 3, verify:
- [ ] Telemetry system is complete and functional
- [ ] Can log events, method calls, queries, and state changes
- [ ] Logs persist to IndexedDB
- [ ] Log viewer UI works (can toggle, filter, search)
- [ ] **Game remains playable** - Original game.js still works if it exists
- [ ] Telemetry doesn't interfere with game functionality

**Note**: Telemetry is ready to be integrated into other modules. Game still uses original game.js.

---

## Phase 3: Yawgmoth - Core Orchestrator

### Step 3.1: Create Event Bus
**Goal**: Basic event system

**Actions**:
1. Create `docs/modules/yawgmoth/event-bus.js`
2. Implement `on(event, handler)`, `off(event, handler)`, `emit(event, data)` methods
3. Store event subscriptions in Map
4. Support multiple handlers per event

**Success Criteria**:
- Can subscribe to events
- Can emit events
- Handlers called when events emitted
- Can unsubscribe

**Test**:
```javascript
const bus = new EventBus();
let called = false;
bus.on('test', () => { called = true; });
bus.emit('test', {});
console.assert(called, 'Handler called');
```

---

### Step 3.2: Integrate Telemetry with Event Bus
**Goal**: Log all events automatically

**Actions**:
1. Wrap EventBus to log all events
2. Log: event name, source module, data, timestamp
3. Log event propagation (which modules receive it)

**Success Criteria**:
- All events logged to telemetry
- Can see events in telemetry viewer
- Event logging doesn't break event system

**Test**: Emit events, verify they appear in telemetry logs

---

### Step 3.3: Create Game Loop Manager
**Goal**: Basic game loop

**Actions**:
1. Create `docs/modules/yawgmoth/game-loop.js`
2. Implement `requestAnimationFrame` loop
3. Calculate deltaTime
4. Provide `start()`, `stop()`, `pause()`, `resume()` methods

**Success Criteria**:
- Game loop runs
- DeltaTime calculated correctly
- Can start/stop/pause/resume

**Test**: Start loop, verify it runs, check deltaTime values

---

### Step 3.4: Create State Manager
**Goal**: Game state management

**Actions**:
1. Create `docs/modules/yawgmoth/state-manager.js`
2. Track current game state (start, playing, paused, etc.)
3. Implement state transitions
4. Emit state change events
5. Log state changes to telemetry

**Success Criteria**:
- Can get current state
- Can transition states
- State changes logged
- Invalid transitions prevented

**Test**: Change states, verify transitions work and are logged

---

### Step 3.5: Create Input Handler
**Goal**: Keyboard input capture

**Actions**:
1. Create `docs/modules/yawgmoth/input-handler.js`
2. Capture keyboard events
3. Track key states (pressed/released)
4. Provide `getInputState()` method
5. Log input events to telemetry (optional, can be verbose)

**Success Criteria**:
- Can detect key presses
- Input state accessible
- Works with arrow keys, WASD, space, etc.

**Test**: Press keys, verify input state updates

---

### Step 3.6: Create Module Manager
**Goal**: Initialize and coordinate modules

**Actions**:
1. Create module registration system
2. Implement `registerModule(name, module)` method
3. Implement `getModule(name)` method
4. Implement module initialization order

**Success Criteria**:
- Can register modules
- Can retrieve modules
- Modules initialized in correct order

**Test**: Register test modules, verify they're accessible

---

### Step 3.7: Complete Yawgmoth Integration
**Goal**: Full orchestrator functionality

**Actions**:
1. Integrate all subsystems (event bus, game loop, state, input, modules)
2. Implement `Yawgmoth` main class
3. Provide initialization method
4. Connect everything together

**Success Criteria**:
- Yawgmoth initializes all subsystems
- Game loop runs
- Events flow through system
- Telemetry logs everything

**Test**: Initialize Yawgmoth, verify all systems work together

### Phase 3 Completion Criteria
**Critical**: Before moving to Phase 4, verify:
- [ ] Yawgmoth orchestrator is complete and functional
- [ ] Event bus works (can subscribe, emit, unsubscribe)
- [ ] Game loop runs and calculates deltaTime correctly
- [ ] State manager tracks and transitions game states
- [ ] Input handler captures keyboard input
- [ ] Module manager can register and retrieve modules
- [ ] Telemetry logs all events automatically
- [ ] **Game remains playable** - Can initialize Yawgmoth without errors
- [ ] All subsystems integrate correctly

**Note**: Yawgmoth is ready to coordinate other modules. Game loop infrastructure is in place.

---

## Phase 4: Leonardo Da Vinci - Renderer

### Step 4.1: Create Canvas Manager
**Goal**: Basic canvas setup

**Actions**:
1. Create `docs/modules/leonardo-da-vinci/renderer.js`
2. Get canvas element from DOM
3. Get 2D context
4. Implement `clearCanvas()` method
5. Implement basic `renderFrame()` that just clears canvas

**Success Criteria**:
- Canvas accessible
- Can clear canvas
- No errors

**Test**: Call renderFrame, verify canvas clears

---

### Step 4.2: Create Background Renderer
**Goal**: Draw stage backgrounds

**Actions**:
1. Create `docs/modules/leonardo-da-vinci/background-renderer.js`
2. Implement `drawBackground(stageConfig)` method
3. Draw solid color background based on stage
4. Query Bookwormy Guy for stage colors

**Success Criteria**:
- Can draw stage 1 background (Deep Space - dark blue)
- Background color matches v2.0
- No rendering errors

**Test**: Draw background, verify color correct

---

### Step 4.3: Add Star Field
**Goal**: Draw parallax star layers

**Actions**:
1. Extend background renderer
2. Create star objects (position, speed, brightness)
3. Draw stars in layers
4. Animate stars moving down
5. Query Bookwormy Guy for star count/config

**Success Criteria**:
- Stars drawn on background
- Stars move down
- Multiple parallax layers visible
- Matches v2.0 appearance

**Test**: Verify stars render and animate correctly

---

### Step 4.4: Create Object Renderer
**Goal**: Draw game objects (player, enemies, etc.)

**Actions**:
1. Create `docs/modules/leonardo-da-vinci/object-renderer.js`
2. Implement `drawObject(object, type)` method
3. Support types: 'player', 'enemy', 'bullet', 'shard', 'weapon'
4. Draw simple rectangles for now (colors from Bookwormy Guy)

**Success Criteria**:
- Can draw player rectangle
- Can draw enemy rectangle
- Can draw bullet rectangle
- Objects appear on canvas

**Test**: Draw test objects, verify they appear

---

### Step 4.5: Create UI Renderer
**Goal**: Draw HUD and screens

**Actions**:
1. Create `docs/modules/leonardo-da-vinci/ui-renderer.js`
2. Implement `drawUI(uiData)` method
3. Draw: health bar, shard counter, score, weapon, level
4. Draw start screen, pause screen, game over screen

**Success Criteria**:
- HUD elements draw correctly
- Start screen displays
- Text readable and positioned correctly

**Test**: Draw UI elements, verify appearance

---

### Step 4.6: Create Render Queue System
**Goal**: Organize render requests

**Actions**:
1. Implement `registerObject(id, type, data)` method
2. Implement `updateObject(id, data)` method
3. Implement `unregisterObject(id)` method
4. Render all registered objects each frame

**Success Criteria**:
- Can register objects for rendering
- Objects render each frame
- Can update object render data
- Can remove objects

**Test**: Register objects, verify they render, update them, remove them

---

### Step 4.7: Integrate Leonardo with Event System
**Goal**: Receive render requests via events

**Actions**:
1. Subscribe to `render:request` events
2. Parse event data and register/update objects
3. Subscribe to `object:destroyed` events to unregister
4. Log render requests to telemetry

**Success Criteria**:
- Receives render requests via events
- Objects render based on events
- Telemetry logs render requests

**Test**: Emit render events, verify objects appear

---

### Step 4.8: Complete Leonardo Integration
**Goal**: Full rendering system

**Actions**:
1. Integrate all renderer subsystems
2. Implement main `LeonardoDaVinci` class
3. Connect to Yawgmoth event bus
4. Render complete frame: background → objects → UI → effects

**Success Criteria**:
- Complete frame renders
- All layers in correct order
- Performance acceptable (60fps)

**Test**: Render full scene, verify all elements visible

### Phase 4 Completion Criteria
**Critical**: Before moving to Phase 5, verify:
- [ ] Leonardo Da Vinci renderer is complete and functional
- [ ] Can render backgrounds (stages, stars, parallax)
- [ ] Can render game objects (player, enemies, bullets, shards)
- [ ] Can render UI (HUD, screens, text)
- [ ] Render queue system works (register, update, unregister)
- [ ] Receives render requests via events
- [ ] Renders at 60fps without performance issues
- [ ] **Game remains playable** - Can render a complete game scene using new modular renderer
- [ ] Visual output matches v2.0 appearance

**Note**: Renderer is ready to display game objects. Can now start replacing game.js rendering with modular system.

---

## Phase 5: Character Trafficker - Player

### Step 5.1: Create Player Class
**Goal**: Basic player object

**Actions**:
1. Create `docs/modules/character-trafficker/player.js`
2. Implement Player class with: x, y, width, height, health, maxHealth
3. Initialize at center-bottom of screen
4. Query Bookwormy Guy for base stats

**Success Criteria**:
- Player object created
- Has correct initial position
- Has correct initial health
- Stats from Bookwormy Guy

**Test**: Create player, verify properties

---

### Step 5.2: Implement Player Movement
**Goal**: Move player with input

**Actions**:
1. Implement `update(deltaTime, inputState)` method
2. Process arrow keys / WASD input
3. Move player based on input and speed
4. Enforce screen boundaries
5. Emit `player:positionChanged` events

**Success Criteria**:
- Player moves with arrow keys
- Player moves with WASD
- Player stays on screen
- Position events emitted

**Test**: Move player, verify position updates, check events in telemetry

---

### Step 5.3: Implement Health System
**Goal**: Player health management

**Actions**:
1. Implement `takeDamage(amount)` method
2. Implement `heal(amount)` method
3. Emit `player:damaged` and `player:healed` events
4. Emit `player:death` event when health reaches 0
5. Log health changes to telemetry

**Success Criteria**:
- Can take damage
- Can heal
- Events emitted correctly
- Death detected

**Test**: Damage player, verify health decreases, check events

---

### Step 5.4: Implement Stats System
**Goal**: Player upgrades and leveling

**Actions**:
1. Create `docs/modules/character-trafficker/stats.js`
2. Track upgrade multipliers (damage, speed, fireRate, etc.)
3. Implement `applyStatBoost(type, value)` method
4. Implement `levelUp()` method
5. Apply multipliers to base stats

**Success Criteria**:
- Can apply stat boosts
- Stats affect player behavior (speed, etc.)
- Level up works
- Stat changes logged

**Test**: Apply boosts, verify stats change, verify effects

---

### Step 5.5: Implement Collection Detection
**Goal**: Detect proximity to collectibles

**Actions**:
1. Implement `getCollectionRange()` method
2. Check distance to shards/weapons
3. Emit `player:collectAttempt` events when in range
4. Query Bookwormy Guy for collection range constant

**Success Criteria**:
- Can detect when near collectible
- Collection range correct
- Events emitted

**Test**: Place player near test object, verify detection

---

### Step 5.6: Integrate Character Trafficker
**Goal**: Complete player module

**Actions**:
1. Implement `CharacterTrafficker` main class
2. Connect to event bus
3. Connect to Bookwormy Guy
4. Update player each frame
5. Handle all player-related events

**Success Criteria**:
- Player module complete
- Player moves, takes damage, levels up
- All events logged to telemetry
- Integrates with Yawgmoth

**Test**: Full player functionality test

### Phase 5 Completion Criteria
**Critical**: Before moving to Phase 6, verify:
- [ ] Character Trafficker module is complete and functional
- [ ] Player can move with arrow keys/WASD
- [ ] Player takes damage and health decreases
- [ ] Player can level up and receive stat boosts
- [ ] Player can detect collectibles (shards, weapons)
- [ ] All player events are logged to telemetry
- [ ] Player integrates with Yawgmoth event system
- [ ] **Game remains playable** - Can create a playable character using new modular system
- [ ] Player behavior matches v2.0 (movement, stats, interactions)

**Note**: Player module is ready. Can now start replacing game.js player code with modular system.

---

## Phase 6: Enemy Controller - Enemies

### Step 6.1: Create Enemy Class
**Goal**: Basic enemy object

**Actions**:
1. Create `docs/modules/enemy-controller/enemy.js`
2. Implement Enemy class with: x, y, width, height, health, type
3. Query Bookwormy Guy for enemy type data
4. Initialize enemy with correct stats

**Success Criteria**:
- Enemy object created
- Stats from Bookwormy Guy
- Correct size and health for type

**Test**: Create enemy, verify properties match Bookwormy Guy data

---

### Step 6.2: Implement Enemy Movement
**Goal**: Move enemies down screen

**Actions**:
1. Implement basic straight-down movement
2. Implement `update(deltaTime)` method
3. Move based on speed from Bookwormy Guy
4. Remove enemy when off-screen
5. Emit `enemy:positionChanged` events

**Success Criteria**:
- Enemies move down
- Speed correct for type
- Enemies removed when off-screen
- Position events logged

**Test**: Spawn enemy, verify movement, check telemetry

---

### Step 6.3: Implement Movement Patterns
**Goal**: Different movement patterns

**Actions**:
1. Create `docs/modules/enemy-controller/movement-patterns.js`
2. Implement: straight, zigzag, spiral, tracking, sidewinder patterns
3. Query Bookwormy Guy for movement pattern data
4. Apply pattern based on enemy type

**Success Criteria**:
- Different patterns work
- Zigzag enemies zigzag
- Spiral enemies spiral
- Patterns match v2.0

**Test**: Spawn different enemy types, verify movement patterns

---

### Step 6.4: Implement Enemy Spawner
**Goal**: Spawn enemies based on level config

**Actions**:
1. Create `docs/modules/enemy-controller/spawner.js`
2. Track spawn timer
3. Query Bookwormy Guy for level config (spawn rate, enemy types)
4. Select enemy type based on weighted probabilities
5. Spawn at random X position
6. Emit `enemy:spawned` events

**Success Criteria**:
- Enemies spawn at correct rate
- Enemy types match level config
- Spawn position random
- Spawn events logged

**Test**: Set level config, verify spawn rate and types

---

### Step 6.5: Implement Enemy Attacks
**Goal**: Enemies shoot bullets

**Actions**:
1. Track attack cooldowns per enemy
2. Query Bookwormy Guy for attack patterns
3. Create bullets based on pattern
4. Emit `enemy:attack` events with bullet data
5. Only attack if level config allows (level 3+)

**Success Criteria**:
- Enemies shoot at correct rate
- Attack patterns correct
- Bullets created
- Attack events logged

**Test**: Spawn shooting enemy, verify bullets created

---

### Step 6.6: Implement Enemy Drops
**Goal**: Enemies drop shards when destroyed

**Actions**:
1. Track which enemies carry shards (30% chance on spawn)
2. When enemy dies, check if carrying shard
3. Emit `enemy:death` event with drop information
4. Emit `drop:shard` event if enemy carried shard

**Success Criteria**:
- Some enemies carry shards
- Shards drop on death
- Drop events logged

**Test**: Destroy enemies, verify drops

---

### Step 6.7: Integrate Enemy Controller
**Goal**: Complete enemy module

**Actions**:
1. Implement `EnemyController` main class
2. Connect to event bus
3. Connect to Bookwormy Guy
4. Update all enemies each frame
5. Handle spawn timing
6. Handle all enemy-related events

**Success Criteria**:
- Enemy module complete
- Enemies spawn, move, attack, die
- All events logged
- Integrates with Yawgmoth

**Test**: Full enemy functionality test

### Phase 6 Completion Criteria
**Critical**: Before moving to Phase 7, verify:
- [ ] Enemy Controller module is complete and functional
- [ ] Enemies spawn at correct rates based on level config
- [ ] Enemies move with correct patterns (straight, zigzag, spiral, tracking, etc.)
- [ ] Enemies can attack and create bullets
- [ ] Enemies can drop shards when destroyed
- [ ] Enemy splitting works (when applicable)
- [ ] All enemy events are logged to telemetry
- [ ] Enemies integrate with Yawgmoth event system
- [ ] **Game remains playable** - Can spawn and interact with enemies using new modular system
- [ ] Enemy behavior matches v2.0 (spawning, movement, attacks, drops)

**Note**: Enemy module is ready. Can now start replacing game.js enemy code with modular system.

---

## Phase 7: Readme Guy - UI & Initialization

### Step 7.1: Create Start Screen
**Goal**: Display startup screen

**Actions**:
1. Create `docs/modules/readme-guy/start-screen.js`
2. Create HTML/CSS for start screen (or render via Leonardo)
3. Display game title, start button, controls info
4. Show/hide start screen methods

**Success Criteria**:
- Start screen displays
- Start button visible
- Controls info readable
- Can hide/show screen

**Test**: Verify start screen appears on page load

---

### Step 7.2: Implement Start Button Handler
**Goal**: Handle game start

**Actions**:
1. Add click handler to start button
2. Emit `game:start` event
3. Hide start screen
4. Log start event to telemetry

**Success Criteria**:
- Clicking start emits event
- Start screen hides
- Event logged

**Test**: Click start, verify event emitted, check telemetry

---

### Step 7.3: Implement Game Initialization
**Goal**: Initialize all modules on start

**Actions**:
1. Create `docs/modules/readme-guy/game-init.js`
2. Coordinate module initialization
3. Initialize: Character Trafficker, Enemy Controller, etc.
4. Set initial game state to 'playing'
5. Start game loop

**Success Criteria**:
- All modules initialized
- Game state set to 'playing'
- Game loop starts
- Initialization logged

**Test**: Start game, verify all modules ready, check telemetry

---

### Step 7.4: Implement Pause Screen
**Goal**: Pause functionality

**Actions**:
1. Create pause screen UI
2. Handle 'P' key press
3. Pause game loop
4. Show pause screen
5. Emit pause/resume events

**Success Criteria**:
- Can pause game
- Pause screen shows
- Can resume game
- Events logged

**Test**: Pause and resume, verify behavior

---

### Step 7.5: Implement Game Over Screen
**Goal**: Game over functionality

**Actions**:
1. Create game over screen
2. Listen for `player:death` event
3. Show game over screen
4. Display final score
5. Provide restart button

**Success Criteria**:
- Game over screen shows on death
- Score displayed
- Can restart game
- Events logged

**Test**: Die, verify game over screen, restart game

---

### Step 7.6: Integrate Readme Guy
**Goal**: Complete UI module

**Actions**:
1. Implement `ReadmeGuy` main class
2. Connect to event bus
3. Handle all UI screens
4. Coordinate game initialization
5. Log all UI events

**Success Criteria**:
- UI module complete
- All screens work
- Game initialization works
- Integrates with Yawgmoth

**Test**: Full UI functionality test

### Phase 7 Completion Criteria
**Critical**: Before moving to Phase 8, verify:
- [ ] Readme Guy module is complete and functional
- [ ] Start screen displays correctly
- [ ] Can click start button and initialize game
- [ ] Pause screen works (P key)
- [ ] Game over screen displays on death
- [ ] Can restart game
- [ ] Game initialization coordinates all modules correctly
- [ ] All UI events are logged to telemetry
- [ ] **Game remains playable** - Can start, pause, and restart game using new modular system
- [ ] UI matches v2.0 appearance and functionality

**Note**: UI module is ready. Game can now be initialized and controlled through modular system.

---

## Phase 8: Integration & Collision

### Step 8.1: Implement Collision Detection
**Goal**: Detect collisions between objects

**Actions**:
1. Create `docs/modules/yawgmoth/collision-manager.js`
2. Implement rectangle collision detection
3. Register colliders (player, enemies, bullets, shards)
4. Check collisions each frame
5. Emit collision events

**Success Criteria**:
- Collisions detected
- Collision events emitted
- Collisions logged to telemetry

**Test**: Create overlapping objects, verify collision detected

---

### Step 8.2: Connect Collisions to Modules
**Goal**: Handle collision responses

**Actions**:
1. Player bullets vs enemies → damage enemies
2. Enemy bullets vs player → damage player
3. Enemies vs player → damage both
4. Player vs shards → collect shards
5. Player vs weapons → collect weapons

**Success Criteria**:
- All collision types handled
- Correct responses (damage, collection, etc.)
- Events flow correctly

**Test**: Test each collision type, verify correct response

---

### Step 8.3: Implement Shard Collection System
**Goal**: Collect shards and track progress

**Actions**:
1. Track shards collected this level
2. When 10 shards collected, emit `level:complete` event
3. Update shard counter in UI
4. Handle level completion sequence

**Success Criteria**:
- Shards collected correctly
- Counter updates
- Level completes at 10 shards
- Completion events logged

**Test**: Collect shards, verify counter, verify level completion

---

### Step 8.4: Implement Level Progression
**Goal**: Advance through levels

**Actions**:
1. Track current stage and level
2. On level complete, advance to next level
3. On stage complete (level 5), advance to next stage
4. Update level config from Bookwormy Guy
5. Show level/stage transition screens

**Success Criteria**:
- Levels advance correctly
- Stages advance correctly
- Config updates
- Transitions work

**Test**: Complete levels, verify progression

---

### Step 8.5: Complete Game Integration
**Goal**: Full game working

**Actions**:
1. Connect all modules together
2. Verify all systems work
3. Test full game flow: start → play → level complete → stage transition
4. Fix any integration issues
5. Verify telemetry logs everything

**Success Criteria**:
- Full game playable
- All features work
- No crashes
- Telemetry comprehensive

**Test**: Play full game, verify all features, check telemetry

### Phase 8 Completion Criteria
**Critical**: Before moving to Phase 9, verify:
- [ ] Collision detection works for all object types
- [ ] Player bullets hit enemies and cause damage
- [ ] Enemy bullets hit player and cause damage
- [ ] Player can collect shards and weapons
- [ ] Shard collection system works (10 shards = level complete)
- [ ] Level progression works (advance to next level/stage)
- [ ] All modules integrated and communicating correctly
- [ ] **Game is fully playable** - Complete game works using new modular system
- [ ] Can play from start to level completion using only modular code
- [ ] Gameplay matches v2.0 (mechanics, feel, difficulty)

**Note**: Game is now fully functional with modular architecture. Original game.js can be removed/replaced.

---

## Phase 9: Polish & Verification

### Step 9.1: Performance Optimization
**Goal**: Ensure 60fps

**Actions**:
1. Profile game performance
2. Optimize render calls
3. Optimize collision detection
4. Limit object counts if needed
5. Use telemetry to find bottlenecks

**Success Criteria**:
- Game runs at 60fps
- No frame drops
- Performance metrics acceptable

**Test**: Run game, monitor FPS, check performance logs

---

### Step 9.2: Verify v2.0 Parity
**Goal**: Game plays like v2.0

**Actions**:
1. Compare gameplay with v2.0
2. Verify all mechanics match
3. Verify all levels/stages match
4. Verify all weapons match
5. Fix any discrepancies

**Success Criteria**:
- Gameplay identical to v2.0
- All features present
- No regressions

**Test**: Play both versions, compare side-by-side

---

### Step 9.3: Telemetry Verification
**Goal**: Telemetry comprehensive and useful

**Actions**:
1. Verify all module interactions logged
2. Test log viewer functionality
3. Test log filtering
4. Test log export
5. Verify logs help with debugging

**Success Criteria**:
- All interactions logged
- Viewer works well
- Logs useful for debugging
- Performance acceptable

**Test**: Use telemetry to debug test issues, verify helpful

---

### Step 9.4: Error Handling
**Goal**: Graceful error handling

**Actions**:
1. Add error handling to all modules
2. Log errors to telemetry
3. Prevent crashes
4. Provide error messages

**Success Criteria**:
- Errors handled gracefully
- Errors logged
- Game doesn't crash
- Error messages helpful

**Test**: Introduce errors, verify handling

---

### Step 9.5: Final Testing
**Goal**: Complete game verification

**Actions**:
1. Play through entire game
2. Test all features
3. Test edge cases
4. Verify telemetry throughout
5. Document any issues

**Success Criteria**:
- Game fully playable
- All features work
- No critical bugs
- Ready for use

**Test**: Comprehensive playthrough

### Phase 9 Completion Criteria
**Critical**: Final verification before declaring v3.0 complete:
- [ ] Game runs at 60fps consistently
- [ ] Performance optimized (no frame drops, acceptable memory usage)
- [ ] Game plays identically to v2.0 (all mechanics match)
- [ ] Telemetry system comprehensive and useful for debugging
- [ ] Error handling prevents crashes
- [ ] All edge cases tested and working
- [ ] **Game is fully playable and polished** - Complete, stable game using modular architecture
- [ ] Can play through all 5 stages, 25 levels without issues
- [ ] All features from v2.0 are present and working
- [ ] Code is modular, maintainable, and ready for v4.0 development

**Note**: v3.0 is complete. Game is fully functional with modular architecture. Ready for v4.0 feature additions.

---

## Success Criteria for Complete v3.0

- [ ] All modules implemented and working
- [ ] Game plays identically to v2.0
- [ ] Telemetry system logs all interactions
- [ ] Can debug issues using telemetry
- [ ] Performance acceptable (60fps)
- [ ] No crashes or critical bugs
- [ ] Code is modular and maintainable
- [ ] Each module can be worked on independently

---

## Notes for Implementation

1. **Don't skip steps** - Each step builds on the previous
2. **Test immediately** - Verify each step before moving on
3. **Use telemetry** - Check logs after each step to verify behavior
4. **Reference v2.0** - Compare with backup to ensure parity
5. **Commit often** - Commit after each successful step
6. **Ask for help** - If stuck on a step, don't proceed until resolved

---

## End of Implementation Steps

This completes the step-by-step implementation guide. Follow these steps in order, verifying each one before proceeding to the next.

