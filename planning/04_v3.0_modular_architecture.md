# Game Design Document v3.0 - Modular Architecture Plan

## Overview
This document specifies the complete modular architecture for version 3.0 of the energy shard collection shooter game. The monolithic `game.js` is being split into 6 independent modules, each with clear responsibilities and interfaces. This architecture allows multiple developers to work independently on different aspects of the game while maintaining clean separation of concerns.

---

## Architecture Philosophy

### Core Principles
1. **Separation of Concerns**: Each module handles one specific domain of functionality
2. **Clear Interfaces**: Modules communicate through well-defined APIs, not direct access
3. **Independence**: Modules can be developed, tested, and modified independently
4. **Single Source of Truth**: Data flows through defined channels, avoiding duplication
5. **Event-Driven Communication**: Modules communicate via events when possible to reduce coupling

### Module Communication Pattern
- **Yawgmoth** (orchestrator) coordinates all modules
- Modules request data from **Bookwormy Guy** (database)
- Modules send render requests to **Leonardo Da Vinci** (renderer)
- Modules emit events that **Yawgmoth** routes to other modules
- No direct module-to-module communication (except through Yawgmoth)
- **All inter-module communication is logged** via the Telemetry System for debugging

### Telemetry & Observability
- **All module interactions are logged** (events, method calls, data exchanges)
- Logs stored in browser IndexedDB for persistence
- Real-time log streaming available for live debugging
- Log viewer UI for reviewing past interactions
- Filterable/searchable logs by module, event type, timestamp
- Performance metrics tracked (call duration, frequency)

---

## Module 1: Character Trafficker

### Role
Manages the player character: health, damage, movement, level progression, upgrades, and interactions with game objects.

### Responsibilities
- **Player Life Management**
  - Track current health and max health
  - Handle damage application and death detection
  - Manage health regeneration (if applicable)
  - Emit health change events

- **Player Movement**
  - Process input (arrow keys, WASD)
  - Calculate player position based on input and speed
  - Enforce screen boundaries
  - Track player position for other modules

- **Player Stats & Leveling**
  - Track player level (separate from stage/level)
  - Manage permanent stat upgrades (damage, speed, fireRate, health, collectionRange)
  - Apply stat multipliers to base values
  - Emit level-up events

- **Player Interactions**
  - Detect proximity to collectibles (shards, weapons)
  - Handle collision with enemies
  - Handle collision with enemy bullets
  - Emit interaction events (collect, hit, etc.)

- **Player Weapon Integration**
  - Track current weapon type and level
  - Provide weapon stats to shooting system
  - Handle weapon collection and upgrades
  - Emit weapon change events

### Public API

```javascript
class CharacterTrafficker {
    // Initialization
    constructor(config, eventBus, dataStore)
    
    // State queries
    getPlayer() // Returns player object with position, health, stats
    getHealth() // Returns {current, max}
    getLevel() // Returns player level number
    getStats() // Returns upgrade multipliers object
    getPosition() // Returns {x, y, width, height}
    getCollectionRange() // Returns collection radius
    
    // Actions
    update(deltaTime, inputState) // Update player state
    takeDamage(amount) // Apply damage, emit events
    heal(amount) // Restore health
    levelUp() // Increment level, emit event
    applyStatBoost(type, value) // Apply permanent upgrade
    collectWeapon(weaponType) // Change weapon, emit event
    upgradeWeapon() // Increment weapon level
    
    // Events emitted
    // - 'player:damaged' {damage, newHealth}
    // - 'player:healed' {amount, newHealth}
    // - 'player:levelUp' {newLevel, statBoost}
    // - 'player:death' {}
    // - 'player:weaponChanged' {weaponType, level}
    // - 'player:positionChanged' {x, y}
    // - 'player:collectAttempt' {x, y, range} // For shard/weapon collection
}
```

### Dependencies
- **Yawgmoth**: Receives events, sends events
- **Bookwormy Guy**: Gets base player stats, weapon data
- **Leonardo Da Vinci**: Receives player render requests (position, health, etc.)

### File Structure
- `modules/character-trafficker.js` - Main module file
- `modules/character-trafficker/player.js` - Player class
- `modules/character-trafficker/stats.js` - Stats management

---

## Module 2: Enemy Controller

### Role
Manages all enemy entities: spawning, movement patterns, attacks, drops, and lifecycle.

### Responsibilities
- **Enemy Spawning**
  - Determine spawn timing based on level config
  - Select enemy type based on weighted probabilities
  - Position enemies at spawn points
  - Track spawn timers and rates
  - Emit spawn events

- **Enemy Movement**
  - Update enemy positions each frame
  - Implement movement patterns (straight, zigzag, spiral, tracking, etc.)
  - Handle boundary conditions (wrap, bounce, despawn)
  - Apply speed multipliers from level config
  - Track enemy positions for collision detection

- **Enemy Attacks**
  - Determine when enemies should attack (based on level, type, timing)
  - Create enemy bullets/projectiles
  - Emit attack events with bullet data
  - Manage attack cooldowns per enemy

- **Enemy Lifecycle**
  - Track enemy health
  - Handle damage application
  - Detect enemy death
  - Handle enemy splitting (when applicable)
  - Emit death events with drop information

- **Enemy Drops**
  - Determine what enemies drop (shards, health, etc.)
  - Track which enemies carry shards
  - Emit drop events when enemies die
  - Manage drop timing and positioning

### Public API

```javascript
class EnemyController {
    // Initialization
    constructor(config, eventBus, dataStore)
    
    // State queries
    getEnemies() // Returns array of all active enemies
    getEnemyCount() // Returns number of active enemies
    getEnemyById(id) // Returns specific enemy object
    
    // Actions
    update(deltaTime, playerPosition) // Update all enemies
    spawnEnemy(type, x, y) // Manually spawn enemy
    damageEnemy(enemyId, damage) // Apply damage to enemy
    removeEnemy(enemyId) // Force remove enemy
    
    // Configuration
    setLevelConfig(levelConfig) // Update spawn rates, enemy types, etc.
    pauseSpawning() // Stop new enemy spawns
    resumeSpawning() // Resume enemy spawns
    
    // Events emitted
    // - 'enemy:spawned' {enemy, type, position}
    // - 'enemy:damaged' {enemy, damage, newHealth}
    // - 'enemy:death' {enemy, position, drops}
    // - 'enemy:attack' {enemy, bullets}
    // - 'enemy:positionChanged' {enemy, position}
    // - 'enemy:split' {originalEnemy, newEnemies}
}
```

### Dependencies
- **Yawgmoth**: Receives events, sends events
- **Bookwormy Guy**: Gets enemy type definitions, movement patterns, attack data
- **Leonardo Da Vinci**: Receives enemy render requests

### File Structure
- `modules/enemy-controller.js` - Main module file
- `modules/enemy-controller/enemy.js` - Enemy class
- `modules/enemy-controller/spawner.js` - Spawning logic
- `modules/enemy-controller/movement-patterns.js` - Movement pattern implementations

---

## Module 3: Readme Guy

### Role
Manages all pre-game UI: startup screen, tutorial, controls display, and game initialization coordination.

### Responsibilities
- **Startup Screen**
  - Display game title and branding
  - Show start button
  - Handle start button clicks
  - Display game information and controls
  - Manage screen visibility states

- **Tutorial System**
  - Display tutorial instructions
  - Show control mappings
  - Display objective information
  - Show weapon information
  - Manage tutorial progression (if multi-step)

- **Game Initialization**
  - Coordinate startup sequence when "Start Game" is clicked
  - Initialize all other modules in correct order
  - Set initial game state
  - Emit game start event
  - Handle game restart

- **UI State Management**
  - Manage screen overlays (start, pause, game over, victory)
  - Handle screen transitions
  - Coordinate with renderer for UI elements

### Public API

```javascript
class ReadmeGuy {
    // Initialization
    constructor(config, eventBus, dataStore)
    
    // State queries
    getCurrentScreen() // Returns 'start', 'playing', 'paused', 'gameOver', 'victory'
    isGameStarted() // Returns boolean
    
    // Actions
    showStartScreen() // Display startup screen
    hideStartScreen() // Hide startup screen
    showTutorial() // Display tutorial
    hideTutorial() // Hide tutorial
    startGame() // Initialize and start game
    pauseGame() // Pause game
    resumeGame() // Resume game
    gameOver(finalScore) // Show game over screen
    showVictory() // Show victory screen
    restartGame() // Reset and restart
    
    // Events emitted
    // - 'game:start' {} // Game starting
    // - 'game:pause' {}
    // - 'game:resume' {}
    // - 'game:restart' {}
    // - 'game:over' {score}
    // - 'game:victory' {}
    // - 'ui:screenChanged' {screen}
}
```

### Dependencies
- **Yawgmoth**: Sends initialization commands, receives game state events
- **Bookwormy Guy**: Gets UI text, tutorial content
- **Leonardo Da Vinci**: Sends UI render requests

### File Structure
- `modules/readme-guy.js` - Main module file
- `modules/readme-guy/start-screen.js` - Start screen UI
- `modules/readme-guy/tutorial.js` - Tutorial system
- `modules/readme-guy/game-init.js` - Initialization logic

---

## Module 4: Leonardo Da Vinci

### Role
Handles all rendering: drawing game objects, UI elements, effects, and managing the canvas.

### Responsibilities
- **Frame Rendering**
  - Clear canvas each frame
  - Draw background layers
  - Draw game objects (player, enemies, bullets, shards, etc.)
  - Draw UI elements (HUD, screens, text)
  - Draw effects (particles, explosions, etc.)
  - Manage render order (background → game objects → UI → effects)

- **Object Rendering**
  - Render player character (position, health indicator, weapon visual)
  - Render enemies (position, type, health bars, shard indicators)
  - Render bullets/projectiles
  - Render collectibles (shards, weapons)
  - Render particles and effects
  - Render bosses with special visuals

- **Background Rendering**
  - Draw stage-specific backgrounds
  - Draw parallax layers (stars, nebula, asteroids, etc.)
  - Draw background elements (asteroids, nebula clouds, energy rifts)
  - Animate background elements

- **UI Rendering**
  - Draw HUD elements (health bar, shard counter, score, weapon, level)
  - Draw screen overlays (start, pause, game over, victory)
  - Draw level completion effects
  - Draw stage transition screens
  - Draw tutorial/instructions

- **Effect Rendering**
  - Draw explosions
  - Draw particle effects
  - Draw level completion animations
  - Draw stat boost notifications
  - Draw easter egg effects

### Public API

```javascript
class LeonardoDaVinci {
    // Initialization
    constructor(canvas, config, eventBus, dataStore)
    
    // Canvas management
    getCanvas() // Returns canvas element
    getContext() // Returns 2D context
    getWidth() // Returns canvas width
    getHeight() // Returns canvas height
    resize(width, height) // Resize canvas
    
    // Rendering
    renderFrame(gameState) // Main render function called each frame
    clearCanvas() // Clear entire canvas
    drawBackground(stageConfig) // Draw background
    drawObject(object, type) // Draw game object (player, enemy, etc.)
    drawUI(uiData) // Draw UI elements
    drawEffect(effect, data) // Draw effect (explosion, particles, etc.)
    
    // Object registration (for render queue)
    registerObject(id, type, data) // Add object to render queue
    unregisterObject(id) // Remove object from render queue
    updateObject(id, data) // Update object render data
    
    // Events listened to
    // Listens for: 'render:request', 'object:created', 'object:updated', 'object:destroyed'
    
    // Events emitted
    // - 'render:frameComplete' {frameTime}
}
```

### Dependencies
- **Yawgmoth**: Receives render requests, sends frame completion events
- **Bookwormy Guy**: Gets visual data (colors, sizes, sprites, animations)
- **All other modules**: Send render data via events

### File Structure
- `modules/leonardo-da-vinci.js` - Main module file
- `modules/leonardo-da-vinci/renderer.js` - Core rendering engine
- `modules/leonardo-da-vinci/background-renderer.js` - Background rendering
- `modules/leonardo-da-vinci/object-renderer.js` - Game object rendering
- `modules/leonardo-da-vinci/ui-renderer.js` - UI rendering
- `modules/leonardo-da-vinci/effect-renderer.js` - Effects rendering

---

## Module 5: Bookwormy Guy

### Role
Central database and configuration store. All game data, stats, definitions, and configurations live here.

### Responsibilities
- **Enemy Data**
  - Store enemy type definitions (health, speed, size, points, fireRate, etc.)
  - Store movement pattern definitions
  - Store attack pattern definitions
  - Store visual data (colors, sizes, sprites)

- **Player Data**
  - Store base player stats
  - Store upgrade definitions
  - Store level progression data

- **Weapon Data**
  - Store all weapon definitions (8 types)
  - Store weapon upgrade levels and stats
  - Store weapon visual data
  - Store weapon drop configurations

- **Level & Stage Data**
  - Store all level configurations (enemy types, spawn rates, speeds, etc.)
  - Store stage configurations (backgrounds, colors, themes)
  - Store boss definitions
  - Store level progression rules

- **Visual Data**
  - Store color palettes per stage
  - Store particle effect definitions
  - Store animation definitions
  - Store sprite/sheet references (if using sprites)

- **Audio Data**
  - Store sound effect definitions
  - Store music track references
  - Store audio configuration

- **Game Configuration**
  - Store game constants (screen size, collection ranges, etc.)
  - Store balance values
  - Store feature flags

### Public API

```javascript
class BookwormyGuy {
    // Initialization
    constructor(config)
    
    // Enemy data
    getEnemyType(type) // Returns enemy definition object
    getEnemyTypes() // Returns all enemy type definitions
    getMovementPattern(patternName) // Returns movement pattern function/definition
    getAttackPattern(patternName) // Returns attack pattern definition
    
    // Player data
    getPlayerBaseStats() // Returns base player stats
    getUpgradeDefinitions() // Returns upgrade type definitions
    
    // Weapon data
    getWeapon(weaponType, level) // Returns weapon stats for type and level
    getWeaponTypes() // Returns all weapon type names
    getWeaponVisualData(weaponType) // Returns visual data for weapon
    
    // Level & stage data
    getLevelConfig(stage, level) // Returns level configuration object
    getStageConfig(stage) // Returns stage configuration object
    getBossConfig(bossType) // Returns boss definition
    
    // Visual data
    getColorPalette(stage) // Returns color palette for stage
    getParticleEffect(effectName) // Returns particle effect definition
    getAnimation(animationName) // Returns animation definition
    
    // Audio data
    getSoundEffect(soundName) // Returns sound effect definition
    getMusicTrack(trackName) // Returns music track reference
    
    // Game configuration
    getGameConfig() // Returns game constants and configuration
    getConstant(name) // Returns specific constant value
    
    // Data updates (for runtime modifications)
    updateLevelConfig(stage, level, config) // Update level config
    updateEnemyType(type, data) // Update enemy definition
}
```

### Dependencies
- **None** - This is a pure data store. Other modules depend on it, but it doesn't depend on others.

### File Structure
- `modules/bookwormy-guy.js` - Main module file
- `modules/bookwormy-guy/data/enemies.js` - Enemy definitions
- `modules/bookwormy-guy/data/weapons.js` - Weapon definitions
- `modules/bookwormy-guy/data/levels.js` - Level configurations
- `modules/bookwormy-guy/data/stages.js` - Stage configurations
- `modules/bookwormy-guy/data/visuals.js` - Visual data
- `modules/bookwormy-guy/data/audio.js` - Audio data
- `modules/bookwormy-guy/data/config.js` - Game configuration

---

## Module 6: Yawgmoth (The Orchestrator)

### Role
Main game loop coordinator, event handler, and communication hub. Connects all modules and ensures everything works together.

### Responsibilities
- **Game Loop Management**
  - Run main game loop (requestAnimationFrame)
  - Calculate deltaTime
  - Coordinate update order of all modules
  - Manage frame timing and performance

- **Event System**
  - Implement event bus for module communication
  - Route events between modules
  - Handle game state transitions
  - Manage event subscriptions

- **Module Coordination**
  - Initialize all modules in correct order
  - Provide modules with dependencies (eventBus, dataStore)
  - Coordinate module updates each frame
  - Handle module errors and recovery

- **Game State Management**
  - Track current game state (start, playing, paused, levelComplete, stageTransition, gameOver, victory)
  - Handle state transitions
  - Coordinate state-dependent behavior across modules

- **Collision Detection Coordination**
  - Coordinate collision checks between game objects
  - Route collision events to appropriate modules
  - Handle collision responses

- **Input Handling**
  - Capture keyboard/mouse input
  - Distribute input state to modules that need it
  - Handle input events (pause, restart, etc.)

- **Audio Coordination**
  - Play sound effects based on events
  - Manage audio context
  - Handle audio settings (mute, volume)

- **Telemetry Integration**
  - Initialize telemetry system
  - Wrap event bus with telemetry logging
  - Wrap module APIs with telemetry logging
  - Provide telemetry access to log viewer

### Public API

```javascript
class Yawgmoth {
    // Initialization
    constructor(canvas, config)
    
    // Game loop
    start() // Start game loop
    stop() // Stop game loop
    pause() // Pause game loop
    resume() // Resume game loop
    
    // Module management
    registerModule(name, module) // Register a module
    getModule(name) // Get module instance
    initializeModules() // Initialize all modules
    
    // Event system
    on(event, handler) // Subscribe to event
    off(event, handler) // Unsubscribe from event
    emit(event, data) // Emit event to all subscribers
    
    // Game state
    getGameState() // Returns current game state
    setGameState(state) // Change game state
    transitionState(from, to) // Handle state transition
    
    // Input
    getInputState() // Returns current input state
    handleInput(event) // Process input event
    
    // Collision
    checkCollisions() // Run collision detection
    registerCollider(id, type, bounds) // Register collider
    unregisterCollider(id) // Unregister collider
    
    // Audio
    playSound(soundName) // Play sound effect
    setAudioEnabled(enabled) // Toggle audio
    
    // Telemetry
    getTelemetry() // Returns telemetry system instance
    enableTelemetry(enabled) // Enable/disable telemetry
    getLogs(filter) // Get telemetry logs
    exportLogs() // Export telemetry logs
}
```

### Dependencies
- **All modules**: Yawgmoth coordinates all of them
- **Bookwormy Guy**: Gets configuration for initialization

### File Structure
- `modules/yawgmoth.js` - Main orchestrator
- `modules/yawgmoth/event-bus.js` - Event system
- `modules/yawgmoth/game-loop.js` - Game loop management
- `modules/yawgmoth/state-manager.js` - State management
- `modules/yawgmoth/input-handler.js` - Input handling
- `modules/yawgmoth/collision-manager.js` - Collision coordination
- `modules/yawgmoth/audio-manager.js` - Audio coordination
- `modules/yawgmoth/telemetry.js` - Telemetry system integration

---

## Module 7: Telemetry System (The Observer)

### Role
Records and stores all inter-module communications, method calls, events, and interactions for debugging and observability. Provides both real-time streaming and historical log review capabilities.

### Responsibilities
- **Event Logging**
  - Log all events emitted through the event bus
  - Record event name, source module, target modules, timestamp, data payload
  - Track event propagation chain

- **Method Call Logging**
  - Intercept and log all public API method calls between modules
  - Record caller module, target module, method name, parameters, return values
  - Track call duration for performance monitoring

- **Data Query Logging**
  - Log all queries to Bookwormy Guy (data store)
  - Record what data was requested, by whom, and when
  - Track data access patterns

- **State Change Logging**
  - Log all game state transitions
  - Record module state changes (player health, enemy count, etc.)
  - Track state change triggers and consequences

- **Performance Metrics**
  - Track method call durations
  - Count events per module per second
  - Monitor render frame times
  - Track memory usage (if available)

- **Log Storage**
  - Store logs in browser IndexedDB for persistence
  - Implement log rotation (keep last N sessions)
  - Compress old logs to save space
  - Allow export of logs as JSON

- **Log Viewing**
  - Provide real-time log stream UI
  - Provide historical log viewer
  - Filter by module, event type, time range
  - Search logs by content
  - Visualize interaction graphs (module A → module B)

### Public API

```javascript
class TelemetrySystem {
    // Initialization
    constructor(config, eventBus)
    
    // Logging
    logEvent(eventName, sourceModule, data, targetModules) // Log event emission
    logMethodCall(callerModule, targetModule, methodName, params, result, duration) // Log method call
    logDataQuery(requesterModule, dataType, query, result) // Log data store query
    logStateChange(module, stateName, oldValue, newValue, trigger) // Log state change
    logError(module, error, context) // Log errors
    
    // Performance
    startTimer(label) // Start performance timer
    endTimer(label) // End timer and log duration
    getMetrics() // Returns performance metrics object
    
    // Storage
    saveLogs() // Persist current logs to IndexedDB
    loadLogs(sessionId) // Load logs from IndexedDB
    exportLogs(format) // Export logs as JSON/CSV
    clearLogs() // Clear all logs
    
    // Viewing
    getLogStream(filter) // Get real-time log stream (returns EventEmitter)
    getLogs(filter) // Get filtered historical logs
    getInteractionGraph() // Returns graph of module interactions
    getModuleStats(moduleName) // Returns statistics for specific module
    
    // Configuration
    setLogLevel(level) // Set logging verbosity (debug, info, warn, error)
    enableModule(moduleName) // Enable logging for specific module
    disableModule(moduleName) // Disable logging for specific module
    setMaxLogSize(size) // Set maximum log size before rotation
}
```

### Log Entry Format

```javascript
{
    id: "log_1234567890",           // Unique log entry ID
    timestamp: 1234567890.123,       // High-precision timestamp
    type: "event" | "method" | "query" | "state" | "error" | "performance",
    source: "CharacterTrafficker",   // Module that initiated action
    target: "Yawgmoth",              // Module that received action (if applicable)
    action: "player:damaged",        // Event name or method name
    data: {                          // Action-specific data
        damage: 20,
        newHealth: 80
    },
    duration: 0.5,                   // Duration in ms (for method calls)
    stackTrace: [...],               // Call stack (for errors)
    sessionId: "session_123",       // Game session ID
    frameNumber: 1234                // Game frame number
}
```

### Log Viewer UI

The telemetry system provides a UI overlay (toggleable with hotkey, e.g., `F12` or `Ctrl+Shift+L`) that displays:

- **Live Log Stream**: Real-time scrolling list of log entries
- **Module Filter**: Checkboxes to show/hide logs from specific modules
- **Type Filter**: Filter by log type (events, methods, queries, etc.)
- **Time Range**: Filter by timestamp
- **Search**: Search log content
- **Interaction Graph**: Visual diagram showing module communication flow
- **Performance Dashboard**: Charts showing call durations, event frequency, etc.
- **Export Button**: Download logs as JSON

### Integration Points

1. **Event Bus Integration**: Wraps event bus to log all events
2. **Module API Wrapping**: Wraps module public APIs to log method calls
3. **Data Store Integration**: Wraps Bookwormy Guy queries to log data access
4. **Game Loop Integration**: Logs frame timing and performance

### Dependencies
- **Yawgmoth**: Receives all events, wraps event bus
- **All Modules**: Wraps their public APIs for logging
- **Browser IndexedDB**: For log persistence

### File Structure
- `modules/telemetry-system.js` - Main telemetry module
- `modules/telemetry-system/logger.js` - Core logging engine
- `modules/telemetry-system/storage.js` - IndexedDB storage
- `modules/telemetry-system/viewer.js` - Log viewer UI
- `modules/telemetry-system/analyzer.js` - Log analysis and metrics
- `modules/telemetry-system/filters.js` - Log filtering logic

### Configuration

```javascript
{
    enabled: true,                    // Enable/disable telemetry
    logLevel: "debug",                // Minimum log level
    maxLogSize: 100000,              // Max log entries before rotation
    persistToIndexedDB: true,         // Save logs to IndexedDB
    realTimeStreaming: true,          // Enable real-time log stream
    modules: {                         // Per-module settings
        "CharacterTrafficker": { enabled: true, level: "debug" },
        "EnemyController": { enabled: true, level: "info" },
        // ... etc
    },
    performanceTracking: true,        // Track performance metrics
    interactionGraph: true,           // Generate interaction graphs
    viewerHotkey: "F12"               // Hotkey to toggle viewer
}
```

### Example Log Output

```
[2024-12-17 20:45:12.345] EVENT | CharacterTrafficker → Yawgmoth
  Action: player:damaged
  Data: { damage: 20, newHealth: 80 }
  Frame: 1234

[2024-12-17 20:45:12.346] METHOD | EnemyController → BookwormyGuy
  Method: getEnemyType
  Params: { type: "basic" }
  Result: { health: 30, speed: 100, ... }
  Duration: 0.2ms

[2024-12-17 20:45:12.347] EVENT | Yawgmoth → LeonardoDaVinci
  Action: render:request
  Data: { type: "object", id: "enemy_123", ... }
  Frame: 1234

[2024-12-17 20:45:12.348] STATE | CharacterTrafficker
  State: health
  Change: 100 → 80
  Trigger: player:damaged event
```

---

## File Structure

```
gog-the-log/
├── docs/
│   ├── index.html
│   ├── styles.css
│   ├── main.js              # Entry point, initializes Yawgmoth
│   └── modules/
│       ├── yawgmoth.js
│       ├── yawgmoth/
│       │   ├── event-bus.js
│       │   ├── game-loop.js
│       │   ├── state-manager.js
│       │   ├── input-handler.js
│       │   ├── collision-manager.js
│       │   ├── audio-manager.js
│       │   └── telemetry.js
│       ├── telemetry-system.js
│       ├── telemetry-system/
│       │   ├── logger.js
│       │   ├── storage.js
│       │   ├── viewer.js
│       │   ├── analyzer.js
│       │   └── filters.js
│       ├── character-trafficker.js
│       ├── character-trafficker/
│       │   ├── player.js
│       │   └── stats.js
│       ├── enemy-controller.js
│       ├── enemy-controller/
│       │   ├── enemy.js
│       │   ├── spawner.js
│       │   └── movement-patterns.js
│       ├── readme-guy.js
│       ├── readme-guy/
│       │   ├── start-screen.js
│       │   ├── tutorial.js
│       │   └── game-init.js
│       ├── leonardo-da-vinci.js
│       ├── leonardo-da-vinci/
│       │   ├── renderer.js
│       │   ├── background-renderer.js
│       │   ├── object-renderer.js
│       │   ├── ui-renderer.js
│       │   └── effect-renderer.js
│       └── bookwormy-guy.js
│       └── bookwormy-guy/
│           ├── data/
│           │   ├── enemies.js
│           │   ├── weapons.js
│           │   ├── levels.js
│           │   ├── stages.js
│           │   ├── visuals.js
│           │   ├── audio.js
│           │   └── config.js
```

---

## Communication Flow Examples

### Example 1: Player Collects Shard (with Telemetry Logging)
1. **Character Trafficker** detects player is near shard (proximity check)
   - **Telemetry logs**: `METHOD | CharacterTrafficker.getPosition()` (duration: 0.1ms)
2. **Character Trafficker** emits `'player:collectAttempt'` event with position
   - **Telemetry logs**: `EVENT | CharacterTrafficker → Yawgmoth | player:collectAttempt`
3. **Yawgmoth** receives event, routes to shard system
   - **Telemetry logs**: `EVENT | Yawgmoth → ShardSystem | player:collectAttempt`
4. Shard system validates collection, emits `'shard:collected'` event
   - **Telemetry logs**: `EVENT | ShardSystem → Yawgmoth | shard:collected`
5. **Character Trafficker** receives `'shard:collected'`, updates shard counter
   - **Telemetry logs**: `STATE | CharacterTrafficker | shardsCollected: 4 → 5`
   - **Telemetry logs**: `EVENT | CharacterTrafficker → Yawgmoth | player:shardCollected`
6. **Yawgmoth** checks if 10 shards collected, emits `'level:complete'` if so
   - **Telemetry logs**: `QUERY | Yawgmoth → CharacterTrafficker | getShardCount()` (result: 5)
7. **Readme Guy** receives `'level:complete'`, shows level complete screen
   - **Telemetry logs**: `EVENT | Yawgmoth → ReadmeGuy | level:complete`
   - **Telemetry logs**: `METHOD | ReadmeGuy.showLevelCompleteScreen()` (duration: 2.3ms)
8. **Leonardo Da Vinci** receives render requests, draws completion effects
   - **Telemetry logs**: `EVENT | Yawgmoth → LeonardoDaVinci | render:request` (type: effect)
   - **Telemetry logs**: `METHOD | LeonardoDaVinci.drawEffect()` (duration: 1.5ms)

### Example 2: Enemy Spawns
1. **Enemy Controller** determines it's time to spawn (spawn timer)
2. **Enemy Controller** queries **Bookwormy Guy** for level config (enemy types, spawn rates)
3. **Enemy Controller** selects enemy type based on weighted probabilities
4. **Enemy Controller** queries **Bookwormy Guy** for enemy definition (health, speed, size, etc.)
5. **Enemy Controller** creates enemy instance
6. **Enemy Controller** emits `'enemy:spawned'` event with enemy data
7. **Yawgmoth** receives event, routes to **Leonardo Da Vinci**
8. **Leonardo Da Vinci** registers enemy for rendering
9. **Yawgmoth** registers enemy collider for collision detection

### Example 3: Enemy Attacks
1. **Enemy Controller** determines enemy should attack (based on level, type, timing)
2. **Enemy Controller** queries **Bookwormy Guy** for attack pattern definition
3. **Enemy Controller** creates bullet objects based on pattern
4. **Enemy Controller** emits `'enemy:attack'` event with bullet data
5. **Yawgmoth** receives event, creates bullet entities
6. **Yawgmoth** registers bullets for collision detection
7. **Leonardo Da Vinci** receives render request, draws bullets

### Example 4: Game Start
1. User clicks "START GAME" button
2. **Readme Guy** receives click event
3. **Readme Guy** calls `startGame()` method
4. **Readme Guy** emits `'game:start'` event
5. **Yawgmoth** receives event, changes game state to 'playing'
6. **Yawgmoth** initializes all modules (if not already initialized)
7. **Yawgmoth** starts game loop
8. **Readme Guy** hides start screen
9. **Character Trafficker** initializes player
10. **Enemy Controller** starts spawning enemies
11. **Leonardo Da Vinci** begins rendering frames

---

## Implementation Instructions for AI Coder

### Phase 1: Setup Module Structure
1. Create `docs/modules/` directory
2. Create subdirectories for each module
3. Create main module files (e.g., `yawgmoth.js`, `character-trafficker.js`, etc.)
4. Create `docs/main.js` as entry point

### Phase 2: Implement Bookwormy Guy (Data Store)
1. Extract all data from current `game.js` into Bookwormy Guy data files
2. Create data structures for:
   - Enemy definitions (from `getLevelConfig()` and enemy type configs)
   - Weapon definitions (from `WeaponSystem.weapons`)
   - Level configurations (from `getLevelConfig()`)
   - Stage configurations (from `getStageConfig()`)
   - Visual data (colors, sizes, etc.)
3. Implement `BookwormyGuy` class with query methods
4. Test: Verify all data can be retrieved correctly

### Phase 3: Implement Telemetry System
1. Create IndexedDB storage system for logs
2. Create core logger that captures events, method calls, queries
3. Create log storage and retrieval system
4. Create log viewer UI (toggleable overlay)
5. Create log filtering and search functionality
6. Create performance metrics tracking
7. Implement `TelemetrySystem` class
8. Test: Verify logs are captured and can be viewed

### Phase 4: Implement Yawgmoth (Orchestrator)
1. Create event bus system (`EventBus` class)
2. **Wrap event bus with telemetry logging** (log all events)
3. Create game loop manager
4. Create state manager
5. Create input handler
6. Create collision manager (coordinate, don't implement full collision yet)
7. Create audio manager
8. **Integrate telemetry system** (initialize, provide access)
9. Implement `Yawgmoth` class that coordinates all subsystems
10. **Wrap module APIs with telemetry** (log all method calls)
11. Test: Verify event system works, game loop runs, telemetry logs events

### Phase 5: Implement Leonardo Da Vinci (Renderer)
1. Extract all rendering code from current `game.js`
2. Create renderer subsystems:
   - Background renderer
   - Object renderer (player, enemies, bullets, shards)
   - UI renderer (HUD, screens)
   - Effect renderer (particles, explosions)
3. Implement render queue system
4. Implement `LeonardoDaVinci` class
5. Test: Verify can render static scene

### Phase 6: Implement Character Trafficker
1. Extract player code from current `game.js`
2. Create `Player` class
3. Implement stats management
4. Implement movement system
5. Implement interaction detection
6. Implement `CharacterTrafficker` class
7. Connect to event bus
8. Test: Verify player moves, takes damage, levels up

### Phase 7: Implement Enemy Controller
1. Extract enemy code from current `game.js`
2. Create `Enemy` class
3. Implement spawner system
4. Implement movement patterns
5. Implement attack system
6. Implement drop system
7. Implement `EnemyController` class
8. Connect to event bus
9. Test: Verify enemies spawn, move, attack, die

### Phase 8: Implement Readme Guy
1. Extract UI/start screen code from current `game.js`
2. Create start screen UI
3. Create tutorial system
4. Create game initialization logic
5. Implement `ReadmeGuy` class
6. Connect to event bus
7. Test: Verify start screen shows, game starts on click

### Phase 9: Integration
1. Update `index.html` to load `main.js` instead of `game.js`
2. In `main.js`, initialize Yawgmoth
3. Yawgmoth initializes all modules (including Telemetry System)
4. Connect all modules via event bus (with telemetry logging)
5. **Enable telemetry logging for all module interactions**
6. **Test telemetry viewer** (press F12 or configured hotkey)
7. Test: Verify full game works end-to-end
8. **Verify telemetry logs all interactions** (check log viewer)

### Phase 10: Collision System Integration
1. Implement collision detection in Yawgmoth's collision manager
2. Connect collision events to appropriate modules
3. Test: Verify player-enemy, bullet-enemy, player-shard collisions work

### Phase 11: Polish & Optimization
1. Optimize render calls
2. Add error handling
3. Add performance monitoring
4. Test all game features
5. Verify no regressions from v2.0

---

## Module Interface Contracts

### Event Bus Interface
All modules must use the event bus for communication:

```javascript
// Subscribe to event
eventBus.on('event:name', (data) => {
    // Handle event
});

// Emit event
eventBus.emit('event:name', { data: 'value' });
```

### Module Initialization Contract
All modules must follow this initialization pattern:

```javascript
class ModuleName {
    constructor(config, eventBus, dataStore) {
        this.config = config;
        this.eventBus = eventBus;
        this.dataStore = dataStore; // Bookwormy Guy instance
        
        this.initialize();
    }
    
    initialize() {
        // Setup event listeners
        this.eventBus.on('event:name', this.handleEvent.bind(this));
        
        // Initialize internal state
    }
    
    update(deltaTime, gameState) {
        // Update logic
    }
}
```

### Render Request Contract
Modules request rendering via events:

```javascript
// Request object render
eventBus.emit('render:request', {
    type: 'object',
    id: 'enemy_123',
    objectType: 'enemy',
    data: {
        x: 100,
        y: 200,
        type: 'basic',
        health: 30,
        // ... other render data
    }
});

// Request UI render
eventBus.emit('render:request', {
    type: 'ui',
    element: 'hud',
    data: {
        health: 100,
        shards: 5,
        // ... other UI data
    }
});
```

---

## Testing Strategy

### Unit Testing
- Test each module independently
- Mock dependencies (eventBus, dataStore)
- Test module APIs in isolation

### Integration Testing
- Test module communication via events
- Test full game flow (start → play → level complete → stage transition)
- Test edge cases (rapid events, missing data, etc.)

### Performance Testing
- Monitor frame rate
- Check memory usage
- Profile render calls
- Optimize bottlenecks

---

## Migration Notes

### From v2.0 to v3.0
1. **Preserve all game mechanics** - v3.0 should play identically to v2.0
2. **Maintain save compatibility** (if save system exists)
3. **Keep all visual assets** - no visual changes, only code structure
4. **Preserve all game data** - move to Bookwormy Guy without modification

### Breaking Changes
- File structure changes (modular)
- No direct access to game objects (must use events)
- Initialization order matters (Yawgmoth → Bookwormy Guy → Others)

---

## Development Workflow

### For Multiple Developers
1. Each developer works on one module
2. Modules communicate only via defined APIs and events
3. Bookwormy Guy is the single source of truth for data
4. Yawgmoth coordinates all interactions
5. Leonardo Da Vinci handles all rendering

### Version Control
- Each module in separate file (easy to track changes)
- Clear commit messages indicating which module changed
- Module interfaces are contracts (don't break without coordination)

### Debugging with Telemetry
1. **When something goes wrong:**
   - Open telemetry viewer (F12 or configured hotkey)
   - Filter logs by time range around when issue occurred
   - Look for error logs or unexpected event sequences
   - Check interaction graph to see module communication flow

2. **Common debugging scenarios:**
   - **Player not taking damage**: Check `player:damaged` events in logs
   - **Enemies not spawning**: Check `enemy:spawned` events and spawn timer logs
   - **Rendering issues**: Check `render:request` events and frame timing
   - **State not updating**: Check state change logs for that module
   - **Performance issues**: Check performance metrics, method call durations

3. **Log analysis:**
   - Export logs as JSON for detailed analysis
   - Use interaction graph to visualize communication patterns
   - Filter by module to see all actions from specific module
   - Search logs for specific event names or data values

4. **Telemetry best practices:**
   - Keep telemetry enabled during development
   - Review logs after each major feature implementation
   - Use telemetry to verify module isolation (modules shouldn't call each other directly)
   - Check performance metrics regularly to catch bottlenecks early

---

## Notes for AI Coder

- **This is a refactoring, not a redesign** - Game should play exactly like v2.0
- **Start with Bookwormy Guy** - Extract all data first, then other modules can use it
- **Event-driven architecture** - Modules don't call each other directly
- **Yawgmoth is the hub** - All coordination goes through it
- **Test incrementally** - Get each module working before moving to next
- **Preserve v2.0 behavior** - Don't change game mechanics, only code structure
- **Telemetry is critical** - Implement telemetry early (Phase 3) and use it for debugging throughout development
- **Log everything** - All module interactions must be logged (events, method calls, queries, state changes)
- **Test telemetry viewer** - Verify you can see module interactions in real-time and review logs after the fact

---

## End of Document

This completes the v3.0 modular architecture design document. All modules, interfaces, responsibilities, and implementation steps are specified for building the modular version of the game.

